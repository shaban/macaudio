#import <Foundation/Foundation.h>
#import <AudioToolbox/AudioToolbox.h>
#import <AVFoundation/AVFoundation.h>
#import <AudioUnit/AUComponent.h>

// Global verbose logging variable (defined here, not extern)
int g_verboseLogging = 0;  // Default to silent

// Setter function for verbose logging
void SetVerboseLogging(int enabled) {
    g_verboseLogging = enabled;
}

// Conditional logging macros
#define VERBOSE_LOG(...) do { if (g_verboseLogging) fprintf(stderr, __VA_ARGS__); } while(0)
#define PROGRESS_LOG(...) fprintf(stderr, __VA_ARGS__)  // Always show progress

// Helper function to convert a FourCharCode (OSType) to an NSString
NSString* StringFromFourCharCode(FourCharCode code) {
    char chars[5];
    chars[0] = (char)((code >> 24) & 0xFF);
    chars[1] = (char)((code >> 16) & 0xFF);
    chars[2] = (char)((code >> 8) & 0xFF);
    chars[3] = (char)(code & 0xFF);
    chars[4] = '\0';
    return [NSString stringWithCString:chars encoding:NSASCIIStringEncoding];
}

// Helper function to convert NSString to FourCharCode (OSType)
FourCharCode FourCharCodeFromString(NSString* string) {
    if (!string || [string length] < 4) {
        return 0;
    }
    
    const char* chars = [string UTF8String];
    return (FourCharCode)((chars[0] << 24) | (chars[1] << 16) | (chars[2] << 8) | chars[3]);
}

// Helper function to convert AudioUnitParameterUnit to NSString
NSString* StringFromAudioUnitParameterUnit(AudioUnitParameterUnit unit) {
    switch (unit) {
        case kAudioUnitParameterUnit_Generic: return @"Generic";
        case kAudioUnitParameterUnit_Indexed: return @"Indexed";
        case kAudioUnitParameterUnit_Boolean: return @"Boolean";
        case kAudioUnitParameterUnit_Percent: return @"Percent";
        case kAudioUnitParameterUnit_Seconds: return @"Seconds";
        case kAudioUnitParameterUnit_SampleFrames: return @"Sample Frames";
        case kAudioUnitParameterUnit_Phase: return @"Phase";
        case kAudioUnitParameterUnit_Rate: return @"Rate";
        case kAudioUnitParameterUnit_Hertz: return @"Hertz";
        case kAudioUnitParameterUnit_Cents: return @"Cents";
        case kAudioUnitParameterUnit_RelativeSemiTones: return @"Relative Semitones";
        case kAudioUnitParameterUnit_MIDINoteNumber: return @"MIDI Note Number";
        case kAudioUnitParameterUnit_MIDIController: return @"MIDI Controller";
        case kAudioUnitParameterUnit_Decibels: return @"Decibels";
        case kAudioUnitParameterUnit_LinearGain: return @"Linear Gain";
        case kAudioUnitParameterUnit_Degrees: return @"Degrees";
        case kAudioUnitParameterUnit_Meters: return @"Meters";
        case kAudioUnitParameterUnit_AbsoluteCents: return @"Absolute Cents";
        case kAudioUnitParameterUnit_Octaves: return @"Octaves";
        case kAudioUnitParameterUnit_BPM: return @"BPM";
        case kAudioUnitParameterUnit_Beats: return @"Beats";
        case kAudioUnitParameterUnit_Milliseconds: return @"Milliseconds";
        case kAudioUnitParameterUnit_Ratio: return @"Ratio";
        case kAudioUnitParameterUnit_CustomUnit: return @"Custom Unit";
        // Missing units from Apple documentation:
        case kAudioUnitParameterUnit_EqualPowerCrossfade: return @"Equal Power Crossfade";
        case kAudioUnitParameterUnit_MixerFaderCurve1: return @"Mixer Fader Curve 1";
        case kAudioUnitParameterUnit_Pan: return @"Pan";
        case kAudioUnitParameterUnit_MIDI2Controller: return @"MIDI 2.0 Controller";
        default: return [NSString stringWithFormat:@"Unknown (%lu)", (unsigned long)unit];
    }
}

// Helper function to get AudioUnitParameterUnit string (alias for compatibility)
NSString* GetAudioUnitParameterUnitString(AudioUnitParameterUnit unit) {
    return StringFromAudioUnitParameterUnit(unit);
}

// Helper function to create error JSON responses
char* CreateErrorJSON(const char* errorMessage) {
    NSDictionary *errorResult = @{
        @"success": @NO,
        @"error": [NSString stringWithUTF8String:errorMessage],
        @"errorCode": @(-1)
    };
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:errorResult options:0 error:nil];
    if (jsonData) {
        NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
        const char *utf8String = [jsonString UTF8String];
        size_t len = strlen(utf8String);
        char *result = (char *)malloc(len + 1);
        if (result) {
            memcpy(result, utf8String, len + 1);
        }
        return result;
    }
    return NULL;
}

@interface AudioUnitInspector : NSObject
- (BOOL)isPresetParameter:(AUParameter *)param audioUnit:(AUAudioUnit *)audioUnit;
- (void)initializeAudioUnitForParameterExtraction:(AUAudioUnit *)audioUnit completion:(void(^)(void))completionBlock;
- (void)performAudioProcessingToCompleteInitialization:(AUAudioUnit *)audioUnit completion:(void(^)(void))completionBlock;
- (void)extractIndexedParameterInfo:(AUParameter *)param paramData:(NSMutableDictionary *)paramData audioUnit:(AUAudioUnit *)audioUnit;
- (void)processParametersForAudioUnit:(AUAudioUnit *)audioUnit withName:(NSString *)auName auParameters:(NSMutableArray *)auParameters;
@end

@implementation AudioUnitInspector

- (BOOL)isPresetParameter:(AUParameter *)param audioUnit:(AUAudioUnit *)audioUnit {
    if (param.unit != kAudioUnitParameterUnit_Indexed) return NO;

    NSString *lowerName = [param.displayName lowercaseString];
    NSArray *presetKeywords = @[@"preset", @"patch", @"sound", @"bank", @"program", @"model", @"amp", @"cab", @"scene"];

    for (NSString *keyword in presetKeywords) {
        if ([lowerName containsString:keyword]) {
            return YES;
        }
    }
    return NO;
}

- (void)initializeAudioUnitForParameterExtraction:(AUAudioUnit *)audioUnit completion:(void(^)(void))completionBlock {
    // Set a realistic buffer size for proper initialization
    audioUnit.maximumFramesToRender = 512;

    // Load a default preset if available - this triggers full plugin initialization
    // Many AudioUnit plugins don't populate their parameter metadata (valueStrings, etc.)
    // until they're properly initialized with a preset and have processed audio
    if (audioUnit.factoryPresets.count > 0) {
        audioUnit.currentPreset = audioUnit.factoryPresets.firstObject;

        // Allow time for preset to load and plugin to initialize
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [self performAudioProcessingToCompleteInitialization:audioUnit completion:completionBlock];
        });
    } else {
        [self performAudioProcessingToCompleteInitialization:audioUnit completion:completionBlock];
    }
}

- (void)performAudioProcessingToCompleteInitialization:(AUAudioUnit *)audioUnit completion:(void(^)(void))completionBlock {
    // Set up proper audio format for processing
    AVAudioFormat *format = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100.0 channels:2];

    if (audioUnit.outputBusses.count > 0) {
        @try {
            // Create silent audio buffers to simulate processing
            // This forces many plugins to complete their internal initialization
            // and populate parameter metadata like valueStrings arrays
            AVAudioPCMBuffer *inputBuffer = [[AVAudioPCMBuffer alloc] initWithPCMFormat:format frameCapacity:512];
            if (inputBuffer) {
                inputBuffer.frameLength = 512;

                // Zero out the buffer (silent audio)
                if (inputBuffer.floatChannelData[0]) {
                    memset(inputBuffer.floatChannelData[0], 0, 512 * sizeof(float));
                }
                if (inputBuffer.format.channelCount > 1 && inputBuffer.floatChannelData[1]) {
                    memset(inputBuffer.floatChannelData[1], 0, 512 * sizeof(float));
                }

                // Try to get and call the render block to trigger processing
                AURenderBlock renderBlock = audioUnit.renderBlock;
                if (renderBlock) {
                    // Create output buffer list
                    AudioBufferList *outputBufferList = (AudioBufferList *)calloc(1, sizeof(AudioBufferList) + sizeof(AudioBuffer));
                    outputBufferList->mNumberBuffers = 1;
                    outputBufferList->mBuffers[0].mNumberChannels = 2;
                    outputBufferList->mBuffers[0].mDataByteSize = 512 * 2 * sizeof(float);
                    outputBufferList->mBuffers[0].mData = calloc(512 * 2, sizeof(float));

                    AudioTimeStamp timeStamp = {0};
                    timeStamp.mSampleTime = 0;
                    timeStamp.mFlags = kAudioTimeStampSampleTimeValid;

                    AudioUnitRenderActionFlags flags = 0;
                    OSStatus status = renderBlock(&flags, &timeStamp, 512, 0, outputBufferList, nil);

                    free(outputBufferList->mBuffers[0].mData);
                    free(outputBufferList);
                }
            }
        } @catch (NSException *exception) {
            // Silent error handling - some plugins may throw exceptions
        }
    }

    // Allow additional time for plugin to complete initialization and update parameter metadata
    // This delay is essential for many plugins to fully populate their valueStrings and other metadata
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        completionBlock();
    });
}

- (void)extractIndexedParameterInfo:(AUParameter *)param paramData:(NSMutableDictionary *)paramData audioUnit:(AUAudioUnit *)audioUnit {
    if (param.unit != kAudioUnitParameterUnit_Indexed) return;

    NSArray<NSString *> *indexedValues = nil;
    NSString *source = nil;

    // Method 1: Standard valueStrings property (most effective - ~80% success rate)
    indexedValues = param.valueStrings;
    if (indexedValues && indexedValues.count > 0) {
        source = @"valueStrings";
    }

    // Method 2: Check if it's a preset parameter (essential for preset-based parameters)
    if (!indexedValues && [self isPresetParameter:param audioUnit:audioUnit]) {
        NSArray *factoryPresets = audioUnit.factoryPresets;
        if (factoryPresets.count > 0) {
            NSMutableArray *presetNames = [NSMutableArray array];
            for (AUAudioUnitPreset *preset in factoryPresets) {
                [presetNames addObject:preset.name];
            }
            indexedValues = presetNames;
            source = @"factoryPresets";
        }
    }

    // Store results in the parameter data for JSON output
    if (indexedValues && indexedValues.count > 0) {
        [paramData setObject:indexedValues forKey:@"indexedValues"];
        [paramData setObject:source forKey:@"indexedValuesSource"];
        VERBOSE_LOG("    ✓ %s: extracted %lu values using %s\n",
                [param.displayName UTF8String],
                (unsigned long)indexedValues.count,
                [source UTF8String]);
    } else {
        // Store range information for manual mapping later
        [paramData setObject:[NSNumber numberWithInt:(int)param.minValue] forKey:@"indexedMinValue"];
        [paramData setObject:[NSNumber numberWithInt:(int)param.maxValue] forKey:@"indexedMaxValue"];
        [paramData setObject:@"none_found" forKey:@"indexedValuesSource"];
        VERBOSE_LOG("    ✗ %s: no indexed values found (range %.0f-%.0f)\n",
                [param.displayName UTF8String], param.minValue, param.maxValue);
    }
}

- (void)processParametersForAudioUnit:(AUAudioUnit *)audioUnit withName:(NSString *)auName auParameters:(NSMutableArray *)auParameters {
    AUParameterTree *parameterTree = audioUnit.parameterTree;
    if (!parameterTree) {
        VERBOSE_LOG("  ✗ No parameter tree available\n");
        return;
    }

    NSArray *allParameters = parameterTree.allParameters;
    
    // Early skip optimization: if no parameters, don't waste time
    if (allParameters.count == 0) {
        VERBOSE_LOG("  ⏭️  Skipping - no parameters\n");
        return;
    }

    // Count indexed parameters first
    NSUInteger indexedCount = 0;
    for (AUParameter *param in allParameters) {
        if (param.unit == kAudioUnitParameterUnit_Indexed) {
            indexedCount++;
        }
    }

    VERBOSE_LOG("  Processing %lu parameters (%lu indexed)\n",
            (unsigned long)allParameters.count, indexedCount);

    // Process all parameters (for JSON output like your working version)
    for (AUParameter *param in allParameters) {
        BOOL isWritable = (param.flags & kAudioUnitParameterFlag_IsWritable) != 0;
        BOOL canRamp = (param.flags & kAudioUnitParameterFlag_CanRamp) != 0;

        // Only include writable or automatable parameters (from your working version)
        if (isWritable || canRamp) {
            NSMutableDictionary *paramData = [NSMutableDictionary dictionary];
            [paramData setObject:param.displayName forKey:@"displayName"];
            [paramData setObject:param.identifier forKey:@"identifier"];
            [paramData setObject:[NSNumber numberWithUnsignedLongLong:param.address] forKey:@"address"];
            [paramData setObject:[NSNumber numberWithFloat:param.minValue] forKey:@"minValue"];
            [paramData setObject:[NSNumber numberWithFloat:param.maxValue] forKey:@"maxValue"];

            // For now, use current value as default (we can enhance this later)
            // Note: Getting true default values requires more complex AudioUnit introspection
            [paramData setObject:[NSNumber numberWithFloat:param.value] forKey:@"defaultValue"];
            [paramData setObject:[NSNumber numberWithFloat:param.value] forKey:@"currentValue"];
            [paramData setObject:StringFromAudioUnitParameterUnit(param.unit) forKey:@"unit"];
            [paramData setObject:[NSNumber numberWithBool:isWritable] forKey:@"isWritable"];
            [paramData setObject:[NSNumber numberWithBool:canRamp] forKey:@"canRamp"];
            [paramData setObject:[NSNumber numberWithUnsignedInteger:param.flags] forKey:@"rawFlags"];

            // Enhanced indexed parameter processing
            if (param.unit == kAudioUnitParameterUnit_Indexed) {
                [self extractIndexedParameterInfo:param paramData:paramData audioUnit:audioUnit];
            }

            [auParameters addObject:paramData]; // Add parameter to the AU's parameter array
        }
    }
}

@end

// Replace the Introspect function around line 296

char *Introspect(const char *type, const char *subtype, const char *manufacturerID){
    @autoreleasepool {
        OSType componentType = FourCharCodeFromString([NSString stringWithUTF8String:type]);
        OSType componentSubType = FourCharCodeFromString([NSString stringWithUTF8String:subtype]);
        OSType componentManufacturer = FourCharCodeFromString([NSString stringWithUTF8String:manufacturerID]);

AudioComponentDescription searchDescription = {
    .componentType = componentType,
    .componentSubType = componentSubType,
    .componentManufacturer = componentManufacturer,
    .componentFlags = 0,
    .componentFlagsMask = 0
};
        
        AudioComponent currentComponent = NULL;
        int count = 0;
        currentComponent = AudioComponentFindNext(currentComponent, &searchDescription);

        AudioUnitInspector *inspector = [[AudioUnitInspector alloc] init];

        if (currentComponent != NULL) {
            CFStringRef nameCFString = NULL;
            AudioComponentCopyName(currentComponent, &nameCFString);

            AudioComponentDescription componentDesc;
            AudioComponentGetDescription(currentComponent, &componentDesc);

            NSString *auName = (nameCFString != NULL) ? (__bridge NSString *)nameCFString : @"[Unknown Name]";

            count++;
            VERBOSE_LOG("Found Audio Unit [%d]: %s\n", count, [auName UTF8String]);

            // Create a mutable dictionary for the current Audio Unit's data
            NSMutableDictionary *auData = [NSMutableDictionary dictionary];
            [auData setObject:auName forKey:@"name"];
            [auData setObject:StringFromFourCharCode(componentDesc.componentManufacturer) forKey:@"manufacturerID"];
            [auData setObject:StringFromFourCharCode(componentDesc.componentType) forKey:@"type"];
            [auData setObject:StringFromFourCharCode(componentDesc.componentSubType) forKey:@"subtype"];
            
            // Add category
            [auData setObject:@"Music Effect" forKey:@"category"];

            // Array to hold parameters for this AU
            NSMutableArray *auParameters = [NSMutableArray array];
            [auData setObject:auParameters forKey:@"parameters"];

            // Add parameter processing using AUv3 approach with synchronous wait
            __block BOOL completed = NO;
            __block NSString *completionResult = nil;
            
            [AUAudioUnit instantiateWithComponentDescription:componentDesc options:kAudioComponentInstantiation_LoadOutOfProcess completionHandler:^(AUAudioUnit * _Nullable audioUnit, NSError * _Nullable error) {
                if (audioUnit) {
                    VERBOSE_LOG("  ✓ AudioUnit instantiated successfully\n");

                    // Set up audio format (same as working version)
                    NSError *busError = nil;
                    AVAudioFormat *renderFormat = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100.0 channels:2];
                    if (audioUnit.outputBusses.count > 0 && ![audioUnit.outputBusses[0] setFormat:renderFormat error:&busError]) {
                        VERBOSE_LOG("  ⚠ Could not set render format: %s\n", [busError.localizedDescription UTF8String]);
                    }

                    // Allocate render resources
                    NSError *allocError = nil;
                    if (![audioUnit allocateRenderResourcesAndReturnError:&allocError]) {
                        VERBOSE_LOG("  ⚠ Could not allocate render resources: %s\n", [allocError.localizedDescription UTF8String]);
                    } else {
                        VERBOSE_LOG("  ✓ Render resources allocated\n");
                    }

                    // Enhanced initialization for better parameter extraction
                    [inspector initializeAudioUnitForParameterExtraction:audioUnit completion:^{
                        // Process parameters and add to auParameters array
                        [inspector processParametersForAudioUnit:audioUnit withName:auName auParameters:auParameters];
                        
                        VERBOSE_LOG("  ✓ Completed parameter extraction (%lu parameters)\n", (unsigned long)auParameters.count);
                        completed = YES;
                    }];
                } else {
                    VERBOSE_LOG("  ✗ Failed to instantiate: %s\n", [error.localizedDescription UTF8String]);
                    completed = YES;
                }
            }];
            
            // Wait for parameter extraction to complete (max 5 seconds)
            NSDate *timeout = [NSDate dateWithTimeIntervalSinceNow:5.0];
            while (!completed && [[NSDate date] compare:timeout] == NSOrderedAscending) {
                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
            }
            
            if (!completed) {
                VERBOSE_LOG("  ⚠ Parameter extraction timed out\n");
            }
            
            // Clean up CFString
            if (nameCFString != NULL) {
                CFRelease(nameCFString);
            }
            
            // Convert auData dictionary to JSON and return
            NSError *jsonError = nil;
            NSData *jsonData = [NSJSONSerialization dataWithJSONObject:auData
                                                               options:NSJSONWritingPrettyPrinted
                                                                 error:&jsonError];
            
            if (jsonData && !jsonError) {
                NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
                
                // Create malloc'd copy for Go
                const char *utf8String = [jsonString UTF8String];
                size_t len = strlen(utf8String);
                char *result = (char *)malloc(len + 1);
                if (result) {
                    memcpy(result, utf8String, len + 1);
                    return result; // Caller must free this
                }
            }
        }
        
        // Return error if plugin not found or JSON failed
        return CreateErrorJSON("Neural DSP plugin not found or JSON serialization failed");
    }
}

// New parameterized introspection function
char *IntrospectPlugin(const char *type, const char *subtype, const char *manufacturerID) {
    @autoreleasepool {
        // Convert C strings to NSString
        NSString *typeStr = [[NSString alloc] initWithUTF8String:type];
        NSString *subtypeStr = [[NSString alloc] initWithUTF8String:subtype];
        NSString *manufacturerStr = [[NSString alloc] initWithUTF8String:manufacturerID];
        
        if (!typeStr || !subtypeStr || !manufacturerStr) {
            return CreateErrorJSON("Invalid input parameters");
        }
        
        // Convert to FourCharCodes
        OSType componentType = FourCharCodeFromString(typeStr);
        OSType componentSubType = FourCharCodeFromString(subtypeStr);
        OSType componentManufacturer = FourCharCodeFromString(manufacturerStr);
        
        AudioComponentDescription searchDescription = {
            .componentType = componentType,
            .componentSubType = componentSubType,
            .componentManufacturer = componentManufacturer,
            .componentFlags = 0,
            .componentFlagsMask = 0
        };
        
        AudioComponent currentComponent = AudioComponentFindNext(NULL, &searchDescription);
        AudioUnitInspector *inspector = [[AudioUnitInspector alloc] init];

        if (currentComponent != NULL) {
            CFStringRef nameCFString = NULL;
            AudioComponentCopyName(currentComponent, &nameCFString);

            AudioComponentDescription componentDesc;
            AudioComponentGetDescription(currentComponent, &componentDesc);

            NSString *auName = (nameCFString != NULL) ? (__bridge NSString *)nameCFString : @"[Unknown Name]";

            VERBOSE_LOG("Found Audio Unit: %s (%s %s %s)\n", [auName UTF8String], type, subtype, manufacturerID);

            // Create a mutable dictionary for the current Audio Unit's data
            NSMutableDictionary *auData = [NSMutableDictionary dictionary];
            [auData setObject:auName forKey:@"name"];
            [auData setObject:manufacturerStr forKey:@"manufacturerID"];
            [auData setObject:typeStr forKey:@"type"];
            [auData setObject:subtypeStr forKey:@"subtype"];
            
            // Add category mapping
            NSString *category = @"Other";
            switch (componentType) {
                case kAudioUnitType_Effect:          category = @"Effect"; break;
                case kAudioUnitType_MusicEffect:     category = @"Music Effect"; break;
                case kAudioUnitType_MusicDevice:     category = @"Instrument"; break;
                case kAudioUnitType_Generator:       category = @"Generator"; break;
                case kAudioUnitType_Mixer:           category = @"Mixer"; break;
                case kAudioUnitType_Panner:          category = @"Panner"; break;
                case kAudioUnitType_Output:          category = @"Output"; break;
                case kAudioUnitType_FormatConverter: category = @"Format Converter"; break;
            }
            [auData setObject:category forKey:@"category"];

            // Array to hold parameters for this AU
            NSMutableArray *auParameters = [NSMutableArray array];
            [auData setObject:auParameters forKey:@"parameters"];

            // Add parameter processing using AUv3 approach with synchronous wait
            __block BOOL completed = NO;
            
            [AUAudioUnit instantiateWithComponentDescription:componentDesc options:kAudioComponentInstantiation_LoadOutOfProcess completionHandler:^(AUAudioUnit * _Nullable audioUnit, NSError * _Nullable error) {
                if (audioUnit) {
                    VERBOSE_LOG("  ✓ AudioUnit instantiated successfully\n");

                    // Set up audio format (same as working version)
                    NSError *busError = nil;
                    AVAudioFormat *renderFormat = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100.0 channels:2];
                    if (audioUnit.outputBusses.count > 0 && ![audioUnit.outputBusses[0] setFormat:renderFormat error:&busError]) {
                        VERBOSE_LOG("  ⚠ Could not set render format: %s\n", [busError.localizedDescription UTF8String]);
                    }

                    // Allocate render resources
                    NSError *allocError = nil;
                    if (![audioUnit allocateRenderResourcesAndReturnError:&allocError]) {
                        VERBOSE_LOG("  ⚠ Could not allocate render resources: %s\n", [allocError.localizedDescription UTF8String]);
                    } else {
                        VERBOSE_LOG("  ✓ Render resources allocated\n");
                    }

                    // Enhanced initialization for better parameter extraction
                    [inspector initializeAudioUnitForParameterExtraction:audioUnit completion:^{
                        // Process parameters and add to auParameters array
                        [inspector processParametersForAudioUnit:audioUnit withName:auName auParameters:auParameters];
                        
                        VERBOSE_LOG("  ✓ Completed parameter extraction (%lu parameters)\n", (unsigned long)auParameters.count);
                        completed = YES;
                    }];
                } else {
                    VERBOSE_LOG("  ✗ Failed to instantiate: %s\n", [error.localizedDescription UTF8String]);
                    completed = YES;
                }
            }];
            
            // Wait for parameter extraction to complete (max 5 seconds)
            NSDate *timeout = [NSDate dateWithTimeIntervalSinceNow:5.0];
            while (!completed && [[NSDate date] compare:timeout] == NSOrderedAscending) {
                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
            }
            
            if (!completed) {
                VERBOSE_LOG("  ⚠ Parameter extraction timed out\n");
            }
            
            // Clean up CFString
            if (nameCFString != NULL) {
                CFRelease(nameCFString);
            }
            
            // Convert auData dictionary to JSON and return
            NSError *jsonError = nil;
            NSData *jsonData = [NSJSONSerialization dataWithJSONObject:auData
                                                               options:NSJSONWritingPrettyPrinted
                                                                 error:&jsonError];
            
            if (jsonData && !jsonError) {
                NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
                
                // Create malloc'd copy for Go
                const char *utf8String = [jsonString UTF8String];
                size_t len = strlen(utf8String);
                char *result = (char *)malloc(len + 1);
                if (result) {
                    memcpy(result, utf8String, len + 1);
                    return result; // Caller must free this
                }
            }
        }
        
        // Return error if plugin not found or JSON failed
        return CreateErrorJSON("Plugin not found or JSON serialization failed");
    }
}

char *IntrospectAudioUnitsWithTimeout(double timeoutSeconds) {
    @autoreleasepool {
        PROGRESS_LOG("Rackless - AudioUnit Plugin Introspection Tool\n");
        PROGRESS_LOG("Scanning for all AudioUnit plugins...\n");

        AudioComponentDescription searchDescription = {
            .componentType = 0,          // 0 = scan all types
            .componentSubType = 0,       // 0 = scan all subtypes
            .componentManufacturer = 0,  // 0 = scan all manufacturers (not just NDSP)
            .componentFlags = 0,
            .componentFlagsMask = 0
        };

        AudioComponent currentComponent = NULL;
        __block int count = 0;

        // Master array to hold all AU dictionaries
        __block NSMutableArray *allAudioUnitsData = [NSMutableArray array];

        AudioUnitInspector *inspector = [[AudioUnitInspector alloc] init];
        dispatch_group_t group = dispatch_group_create();

        do {
            currentComponent = AudioComponentFindNext(currentComponent, &searchDescription);

            if (currentComponent != NULL) {
                dispatch_group_enter(group);

                CFStringRef nameCFString = NULL;
                AudioComponentCopyName(currentComponent, &nameCFString);

                AudioComponentDescription componentDesc;
                AudioComponentGetDescription(currentComponent, &componentDesc);

                NSString *auName = (nameCFString != NULL) ? (__bridge NSString *)nameCFString : @"[Unknown Name]";

                count++;
                VERBOSE_LOG("Found Audio Unit [%d]: %s\n", count, [auName UTF8String]);

                // Create a mutable dictionary for the current Audio Unit's data
                NSMutableDictionary *auData = [NSMutableDictionary dictionary];
                [auData setObject:auName forKey:@"name"];
                [auData setObject:StringFromFourCharCode(componentDesc.componentManufacturer) forKey:@"manufacturerID"];
                [auData setObject:StringFromFourCharCode(componentDesc.componentType) forKey:@"type"];
                [auData setObject:StringFromFourCharCode(componentDesc.componentSubType) forKey:@"subtype"];

                // Array to hold parameters for this AU
                NSMutableArray *auParameters = [NSMutableArray array];
                [auData setObject:auParameters forKey:@"parameters"];

                [AUAudioUnit instantiateWithComponentDescription:componentDesc options:kAudioComponentInstantiation_LoadOutOfProcess completionHandler:^(AUAudioUnit * _Nullable audioUnit, NSError * _Nullable error) {
                    if (audioUnit) {
                        VERBOSE_LOG("  ✓ AudioUnit instantiated successfully\n");

                        // Set up audio format on all busses (from your working version)
                        NSError *busError = nil;
                        AVAudioFormat *renderFormat = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100.0 channels:2];
                        if (audioUnit.outputBusses.count > 0 && ![audioUnit.outputBusses[0] setFormat:renderFormat error:&busError]) {
                            VERBOSE_LOG("  ⚠ Could not set render format: %s\n", [busError.localizedDescription UTF8String]);
                        }

                        // Allocate render resources
                        NSError *allocError = nil;
                        if (![audioUnit allocateRenderResourcesAndReturnError:&allocError]) {
                            VERBOSE_LOG("  ⚠ Could not allocate render resources: %s\n", [allocError.localizedDescription UTF8String]);
                        } else {
                            VERBOSE_LOG("  ✓ Render resources allocated\n");
                        }

                        // Enhanced initialization for better parameter extraction
                        [inspector initializeAudioUnitForParameterExtraction:audioUnit completion:^{
                            // Check if this plugin has parameters before processing
                            AUParameterTree *parameterTree = audioUnit.parameterTree;
                            NSArray *allParameters = parameterTree ? parameterTree.allParameters : nil;
                            
                            if (!allParameters || allParameters.count == 0) {
                                // Skip plugins with no parameters - they're not useful for live performance control
                                VERBOSE_LOG("  ⏭️  Completed inspection of %s (skipped - no parameters)\n", [auName UTF8String]);
                                
                                // Don't add to results - we only want plugins with parameters
                                if (nameCFString != NULL) {
                                    CFRelease(nameCFString);
                                }
                                dispatch_group_leave(group);
                                return;
                            }
                            
                            // Process parameters and add to auParameters array
                            [inspector processParametersForAudioUnit:audioUnit withName:auName auParameters:auParameters];

                            // Only add plugins that have parameters to the results
                            if (auParameters.count > 0) {
                                VERBOSE_LOG("  ✓ Completed inspection of %s (%lu parameters)\n", [auName UTF8String], (unsigned long)auParameters.count);
                                
                                // Add the collected AU data to the master array
                                @synchronized(allAudioUnitsData) {
                                    [allAudioUnitsData addObject:auData];
                                }
                            } else {
                                VERBOSE_LOG("  ⏭️  Completed inspection of %s (skipped - no usable parameters)\n", [auName UTF8String]);
                            }

                            if (nameCFString != NULL) {
                                CFRelease(nameCFString);
                            }
                            dispatch_group_leave(group);
                        }];

                    } else {
                        // Log errors, but don't add failed instantiations to results (they're not useful)
                        VERBOSE_LOG("  ✗ Failed to instantiate: %s\n", [error.localizedDescription UTF8String]);

                        if (nameCFString != NULL) {
                            CFRelease(nameCFString);
                        }
                        dispatch_group_leave(group);
                    }
                }];
            }
        } while (currentComponent != NULL);

        PROGRESS_LOG("Waiting for all AudioUnit inspections to complete...\n");
        
        // Wait with immediate timeout for maximum performance
        dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.0 * NSEC_PER_SEC));
        long result = dispatch_group_wait(group, timeout);
        
        if (result != 0) {
            // Timeout occurred - this is expected with immediate timeout for maximum performance
            PROGRESS_LOG("⚠️  Timeout: AudioUnit inspection took longer than expected. This may indicate:\n");
            PROGRESS_LOG("   - A plugin is hanging or taking too long to initialize\n");
            PROGRESS_LOG("   - System is under heavy load\n");
            PROGRESS_LOG("   - A plugin has crashed and is waiting indefinitely\n");
            PROGRESS_LOG("Returning partial results from %lu completed inspections...\n", 
                        (unsigned long)allAudioUnitsData.count);
        }

        NSUInteger usablePlugins = allAudioUnitsData.count;
        if (result == 0) {
            PROGRESS_LOG("Inspection complete. Found %lu usable plugins (with parameters) out of %d total AudioUnits.\n", 
                        (unsigned long)usablePlugins, count);
        } else {
            PROGRESS_LOG("Inspection timed out. Found %lu usable plugins (with parameters) from partial scan of %d total AudioUnits.\n", 
                        (unsigned long)usablePlugins, count);
        }

        // Convert the collected data to JSON and output to stdout
        NSError *jsonError = nil;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:allAudioUnitsData
                                                           options:NSJSONWritingPrettyPrinted
                                                             error:&jsonError];

        if (jsonData && !jsonError) {
            NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];

            // Copy the UTF8 string to a malloc'd buffer to avoid returning an inner pointer
            const char *utf8Str = [jsonString UTF8String];
            char *result = malloc(strlen(utf8Str) + 1);
            if (result) {
                strcpy(result, utf8Str);
            }
            // Log success to stderr
            PROGRESS_LOG("JSON output complete (%.1f KB)\n", (double)jsonData.length / 1024.0);

            return result;
        } else {
            PROGRESS_LOG("Error generating JSON: %s\n", [jsonError.localizedDescription UTF8String]);
            return NULL;
        }
    }
}

// Quick scan function - just enumerate AudioComponents without instantiation
char *QuickScanAudioUnits(void) {
    @autoreleasepool {
        // Silent operation by default (follows devices package pattern)
        
        AudioComponentDescription searchDescription = {
            .componentType = 0,          // 0 = scan all types
            .componentSubType = 0,       // 0 = scan all subtypes
            .componentManufacturer = 0,  // 0 = scan all manufacturers
            .componentFlags = 0,
            .componentFlagsMask = 0
        };

        AudioComponent currentComponent = NULL;
        int count = 0;

        // Array to hold basic plugin info (no parameters)
        NSMutableArray *pluginList = [NSMutableArray array];

        do {
            currentComponent = AudioComponentFindNext(currentComponent, &searchDescription);

            if (currentComponent != NULL) {
                CFStringRef nameCFString = NULL;
                AudioComponentCopyName(currentComponent, &nameCFString);

                AudioComponentDescription componentDesc;
                AudioComponentGetDescription(currentComponent, &componentDesc);

                NSString *auName = (nameCFString != NULL) ? (__bridge NSString *)nameCFString : @"[Unknown Name]";

                count++;

                // Add human-readable category for UI filtering
                NSString *category = @"Other";
                switch (componentDesc.componentType) {
                    case kAudioUnitType_Effect:
                        category = @"Effect";
                        break;
                    case kAudioUnitType_MusicEffect:
                        category = @"Music Effect";
                        break;
                    case kAudioUnitType_MusicDevice:
                        category = @"Instrument";
                        break;
                    case kAudioUnitType_Generator:
                        category = @"Generator";
                        break;
                    case kAudioUnitType_Mixer:
                        category = @"Mixer";
                        break;
                    case kAudioUnitType_Panner:
                        category = @"Panner";
                        break;
                    case kAudioUnitType_Output:
                        category = @"Output";
                        break;
                    case kAudioUnitType_FormatConverter:
                        category = @"Format Converter";
                        break;
                    default:
                        category = @"Other";
                        break;
                }

                // Create basic plugin info dictionary (NO parameters)
                NSDictionary *pluginInfo = @{
                    @"name": auName,
                    @"manufacturerID": StringFromFourCharCode(componentDesc.componentManufacturer),
                    @"type": StringFromFourCharCode(componentDesc.componentType),
                    @"subtype": StringFromFourCharCode(componentDesc.componentSubType),
                    @"category": category
                };

                [pluginList addObject:pluginInfo];

                if (nameCFString) {
                    CFRelease(nameCFString);
                }
            }
        } while (currentComponent != NULL);

        // Return success result with plugin list (like devices pattern)
        NSDictionary *successResult = @{
            @"success": @YES,
            @"plugins": pluginList,
            @"pluginCount": @([pluginList count]),
            @"totalPluginsScanned": @(count)
        };

        NSError *jsonError = nil;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:successResult options:0 error:&jsonError];

        if (!jsonData || jsonError) {
            NSDictionary *errorResult = @{
                @"success": @NO,
                @"error": @"JSON serialization failed",
                @"errorCode": @(-2),
                @"plugins": @[]
            };
            jsonData = [NSJSONSerialization dataWithJSONObject:errorResult options:0 error:nil];
        }

        NSString *result = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
        return strdup([result UTF8String]);
    }
}

// Single plugin introspection function - inspect one specific plugin by type, subtype, and manufacturer
char *IntrospectSingleAudioUnit(const char *type, const char *subtype, const char *manufacturerID) {
    @autoreleasepool {
        // Convert C strings to NSString with proper memory management
        NSString *typeStr = [[NSString alloc] initWithUTF8String:type];
        NSString *subtypeStr = [[NSString alloc] initWithUTF8String:subtype];
        NSString *manufacturerStr = [[NSString alloc] initWithUTF8String:manufacturerID];
        
        if (!typeStr || !subtypeStr || !manufacturerStr) {
            return CreateErrorJSON("Invalid input parameters");
        }
        
        // Convert to FourCharCodes safely
        OSType componentType = FourCharCodeFromString(typeStr);
        OSType componentSubType = FourCharCodeFromString(subtypeStr);
        OSType componentManufacturer = FourCharCodeFromString(manufacturerStr);
        
        // Create component description for AUv3
        AudioComponentDescription componentDesc = {0};
        componentDesc.componentType = componentType;
        componentDesc.componentSubType = componentSubType;
        componentDesc.componentManufacturer = componentManufacturer;
        componentDesc.componentFlags = 0;
        componentDesc.componentFlagsMask = 0;
        
        // Find the component
        AudioComponent component = AudioComponentFindNext(NULL, &componentDesc);
        if (!component) {
            return CreateErrorJSON("AudioUnit component not found");
        }
        
        // Get component name safely
        CFStringRef componentNameRef = NULL;
        OSStatus status = AudioComponentCopyName(component, &componentNameRef);
        if (status != noErr || !componentNameRef) {
            return CreateErrorJSON("Failed to get component name");
        }
        
        // Convert to NSString and retain properly
        NSString *componentName = (__bridge NSString *)componentNameRef;
        
        PROGRESS_LOG("Introspecting single plugin: %s\n", [componentName UTF8String]);
        
        PROGRESS_LOG("Introspecting single plugin: %s\n", [componentName UTF8String]);
        
        // Create the result structure
        NSMutableDictionary *pluginDict = [[NSMutableDictionary alloc] init];
        pluginDict[@"success"] = @YES;
        
        NSMutableDictionary *pluginData = [[NSMutableDictionary alloc] init];
        pluginData[@"name"] = componentName;
        pluginData[@"manufacturerID"] = manufacturerStr;
        pluginData[@"type"] = typeStr;
        pluginData[@"subtype"] = subtypeStr;
        
        // Add category mapping
        NSString *category = @"Other";
        switch (componentType) {
            case kAudioUnitType_Effect:          category = @"Effect"; break;
            case kAudioUnitType_MusicEffect:     category = @"Music Effect"; break;
            case kAudioUnitType_MusicDevice:     category = @"Instrument"; break;
            case kAudioUnitType_Generator:       category = @"Generator"; break;
            case kAudioUnitType_Mixer:           category = @"Mixer"; break;
            case kAudioUnitType_Panner:          category = @"Panner"; break;
            case kAudioUnitType_Output:          category = @"Output"; break;
            case kAudioUnitType_FormatConverter: category = @"Format Converter"; break;
        }
        pluginData[@"category"] = category;
        
        // Array to hold ALL parameters (no filtering)
        NSMutableArray *parametersArray = [[NSMutableArray alloc] init];
        
        // Try synchronous instantiation first
        NSError *instantiationError = nil;
        AUAudioUnit *audioUnit = [[AUAudioUnit alloc] initWithComponentDescription:componentDesc error:&instantiationError];
        
        if (!audioUnit) {
            PROGRESS_LOG("Failed to instantiate AUv3 synchronously: %s\n", [instantiationError.localizedDescription UTF8String]);
            // Fallback: return basic info with empty parameters
            pluginData[@"parameters"] = parametersArray;
            pluginDict[@"plugin"] = pluginData;
        } else {
            PROGRESS_LOG("✓ AUv3 AudioUnit instantiated successfully\n");
            
            // Set up audio format (same as working version)
            NSError *busError = nil;
            AVAudioFormat *renderFormat = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100.0 channels:2];
            if (audioUnit.outputBusses.count > 0 && ![audioUnit.outputBusses[0] setFormat:renderFormat error:&busError]) {
                PROGRESS_LOG("⚠ Could not set render format: %s\n", [busError.localizedDescription UTF8String]);
            }
            
            // Allocate render resources
            NSError *allocError = nil;
            if (![audioUnit allocateRenderResourcesAndReturnError:&allocError]) {
                PROGRESS_LOG("⚠ Could not allocate render resources: %s\n", [allocError.localizedDescription UTF8String]);
            } else {
                PROGRESS_LOG("✓ Render resources allocated\n");
            }
            
            // Get parameter tree directly (no async setup for single plugin)
            AUParameterTree *parameterTree = audioUnit.parameterTree;
            if (!parameterTree) {
                PROGRESS_LOG("⚠ No parameter tree available\n");
                pluginData[@"parameters"] = parametersArray; // Empty array
            } else {
                NSArray *allParameters = parameterTree.allParameters;
                PROGRESS_LOG("Processing %lu parameters (NO FILTERING - include ALL)\n", (unsigned long)allParameters.count);
                
                // Create inspector instance for indexed parameter extraction
                AudioUnitInspector *inspector = [[AudioUnitInspector alloc] init];
                
                // Process ALL parameters (no filtering like the working version does)
                for (AUParameter *param in allParameters) {
                    @autoreleasepool {
                        NSMutableDictionary *paramData = [NSMutableDictionary dictionary];
                        
                        // Use the same properties as the working processParametersForAudioUnit
                        [paramData setObject:param.displayName forKey:@"displayName"];
                        [paramData setObject:param.identifier forKey:@"identifier"];
                        [paramData setObject:[NSNumber numberWithUnsignedLongLong:param.address] forKey:@"address"];
                        [paramData setObject:[NSNumber numberWithFloat:param.minValue] forKey:@"minValue"];
                        [paramData setObject:[NSNumber numberWithFloat:param.maxValue] forKey:@"maxValue"];
                        [paramData setObject:[NSNumber numberWithFloat:param.value] forKey:@"defaultValue"];
                        [paramData setObject:[NSNumber numberWithFloat:param.value] forKey:@"currentValue"];
                        [paramData setObject:StringFromAudioUnitParameterUnit(param.unit) forKey:@"unit"];
                        
                        // Use same boolean creation as working version
                        BOOL isWritable = (param.flags & kAudioUnitParameterFlag_IsWritable) != 0;
                        BOOL canRamp = (param.flags & kAudioUnitParameterFlag_CanRamp) != 0;
                        [paramData setObject:[NSNumber numberWithBool:isWritable] forKey:@"isWritable"];
                        [paramData setObject:[NSNumber numberWithBool:canRamp] forKey:@"canRamp"];
                        [paramData setObject:[NSNumber numberWithUnsignedInteger:param.flags] forKey:@"rawFlags"];
                        
                        // Use the inspector's indexed parameter extraction (same as working version)
                        if (param.unit == kAudioUnitParameterUnit_Indexed) {
                            [inspector extractIndexedParameterInfo:param paramData:paramData audioUnit:audioUnit];
                        }
                        
                        // Add ALL parameters to array (no filtering)
                        [parametersArray addObject:paramData];
                    }
                }
                
                PROGRESS_LOG("✓ Processed %lu parameters\n", (unsigned long)parametersArray.count);
                pluginData[@"parameters"] = parametersArray;
            }
            
            // Clean up the AUv3 instance
            audioUnit = nil;
        }
        
        // Finalize the result
        pluginDict[@"plugin"] = pluginData;
        
        // Clean up CFString
        if (componentNameRef) {
            CFRelease(componentNameRef);
        }
        
        // Convert to JSON with error handling
        NSError *jsonError = nil;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:pluginDict
                                                           options:0 // No pretty printing for production
                                                             error:&jsonError];
        
        if (jsonData && !jsonError) {
            NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
            
            // Create a copy that malloc manages (not ARC)
            const char *utf8String = [jsonString UTF8String];
            size_t len = strlen(utf8String);
            char *result = (char *)malloc(len + 1);
            if (result) {
                memcpy(result, utf8String, len + 1);
                PROGRESS_LOG("Single plugin introspection complete\n");
                return result; // Caller must free this
            }
        }
        
        // Fallback error
        return CreateErrorJSON("Failed to serialize plugin data");
        
    } // autoreleasepool
}
